// Copyright 2023 StarkWare Industries Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.starkware.co/open-source-license/
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.

#ifndef STARKWARE_ALGEBRA_FIELDS_EXTENSION_FIELD_ELEMENT_H_
#define STARKWARE_ALGEBRA_FIELDS_EXTENSION_FIELD_ELEMENT_H_

#include <string>
#include <vector>

#include "starkware/algebra/big_int.h"
#include "starkware/algebra/field_element_base.h"
#include "starkware/algebra/field_operations.h"
#include "starkware/algebra/fields/long_field_element.h"

namespace starkware {

/*
  Represents an extension field element of a given field F (F's elements are of type FieldElementT).
  An element of the extension field is coef0_+coef_1*sqrt(g) for g = FieldElementT::Generator() and
  coef0_, coef1_ are of type FieldElementT. In other words, the extension filed is F[X]/(x^2-g).
*/
template <typename FieldElementT>
class ExtensionFieldElement : public FieldElementBase<ExtensionFieldElement<FieldElementT>> {
 public:
#ifdef NDEBUG
  // We allow the use of the default constructor only in Release builds in order to reduce
  // memory allocation time for vectors of field elements.
  ExtensionFieldElement() = default;
#else
  // In debug builds, we make sure that the default constructor is not called at all.
  ExtensionFieldElement() = delete;
#endif

  /*
    Creates an extension field element from two field elements.
  */
  constexpr ExtensionFieldElement(const FieldElementT& coef0, const FieldElementT& coef1)
      : coef0_(coef0), coef1_(coef1) {}

  static ExtensionFieldElement Uninitialized() {
    return Zero();
  }

  const auto& GetCoef0() const { return coef0_; }
  const auto& GetCoef1() const { return coef1_; }

  ExtensionFieldElement operator+(const ExtensionFieldElement& rhs) const;

  ExtensionFieldElement operator-(const ExtensionFieldElement& rhs) const;

  ExtensionFieldElement operator-() const { return ExtensionFieldElement(-coef0_, -coef1_); }

  ExtensionFieldElement operator*(const ExtensionFieldElement& rhs) const;

  bool operator==(const ExtensionFieldElement& rhs) const;

  ExtensionFieldElement Inverse() const;

  static constexpr ExtensionFieldElement Zero() {
    return ExtensionFieldElement(FieldElementT::Zero(), FieldElementT::Zero());
  }

  static constexpr ExtensionFieldElement One() {
    return ExtensionFieldElement(FieldElementT::One(), FieldElementT::Zero());
  }

  /*
    Returns a random extension field element: its first and second coefficients are random
    FieldElementT generated by FieldElementT::RandomElement.
  */
  static ExtensionFieldElement RandomElement(PrngBase* prng) {
    const auto coef0 = FieldElementT::RandomElement(prng);
    const auto coef1 = FieldElementT::RandomElement(prng);
    return ExtensionFieldElement(coef0, coef1);
  }

  /*
    Returns a base field random element as an extension field element.
  */
  static ExtensionFieldElement RandomBaseElement(Prng* prng) {
    const auto coef0 = FieldElementT::RandomElement(prng);
    return ExtensionFieldElement(coef0, FieldElementT::Zero());
  }

  /*
    Converts this extension field element to bytes using ToBytes of FieldElementT. The result is
    the concatenation of coef0_.ToBytes() and coef1_.ToBytes().
  */
  void ToBytes(gsl::span<std::byte> span_out, bool use_big_endian = true) const;

  static ExtensionFieldElement FromBytes(
      gsl::span<const std::byte> bytes, bool use_big_endian = true);

  std::string ToString() const;

  static ExtensionFieldElement FromString(const std::string& s);

  static constexpr auto FieldSize() {
    return FieldElementT::FieldSize() * FieldElementT::FieldSize();
  }

  static constexpr ExtensionFieldElement FromUint(uint64_t val) {
    return ExtensionFieldElement(FieldElementT::FromUint(val), FieldElementT::Zero());
  }

  static ExtensionFieldElement Generator();

  static constexpr auto Characteristic() { return FieldElementT::Characteristic(); }

  static constexpr auto PrimeFactors();

  static constexpr size_t SizeInBytes() { return FieldElementT::SizeInBytes() * 2; }

  bool InBaseField() const { return coef1_ == FieldElementT::Zero(); }

  static constexpr ExtensionFieldElement ConstexprFromBigInt(const BigInt<1>& val);

  static ExtensionFieldElement<FieldElementT> GetBaseGenerator() {
    return {FieldElementT::Generator(), FieldElementT::Zero()};
  }

 private:
  /*
    The extension field element is coef0_+coef_1*sqrt(g) for g = FieldElementT::Generator() and
    coef0_, coef1_ are of type FieldElementT.
  */
  FieldElementT coef0_;
  FieldElementT coef1_;
};

}  // namespace starkware

#include "starkware/algebra/fields/extension_field_element.inl"

#endif  // STARKWARE_ALGEBRA_FIELDS_EXTENSION_FIELD_ELEMENT_H_
