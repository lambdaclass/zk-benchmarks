// Copyright 2023 StarkWare Industries Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License").
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.starkware.co/open-source-license/
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions
// and limitations under the License.

#ifndef STARKWARE_ALGEBRA_FIELDS_FRACTION_FIELD_ELEMENT_H_
#define STARKWARE_ALGEBRA_FIELDS_FRACTION_FIELD_ELEMENT_H_

#include <string>
#include <vector>

#include "starkware/algebra/big_int.h"
#include "starkware/algebra/field_element_base.h"
#include "starkware/algebra/field_operations.h"

namespace starkware {

/*
  Represents a field element as an element of the fraction field of the original field. The elements
  of the fraction field are a/b for a,b in the original field, and b != 0. The representation of
  a FieldElementT b is b/1. Addition and multiplication for the fraction field are defined naturally
  (see functions operator+ and operator*). The resulting field is identical to the original field.
  This fractional representation of the original field enables to cheaply perform an inverse
  operation: the inverse of a/b is simply b/a.
*/
template <typename FieldElementT>
class FractionFieldElement : public FieldElementBase<FractionFieldElement<FieldElementT>> {
 public:
  explicit constexpr FractionFieldElement(const FieldElementT& num_val)
      : numerator_(num_val), denominator_(FieldElementT::One()) {}

  /*
    Creates a FractionFieldElement with the value num_val/denom_val.
    denom_val can't be zero.
  */
  constexpr FractionFieldElement(const FieldElementT& num_val, const FieldElementT& denom_val)
      : numerator_(num_val), denominator_(denom_val) {
    ASSERT_VERIFIER(denominator_ != FieldElementT::Zero(), "Denominator can't be zero.");
  }

  static FractionFieldElement Uninitialized() {
    return Zero();
  }

  FractionFieldElement operator+(const FractionFieldElement& rhs) const;

  FractionFieldElement operator-(const FractionFieldElement& rhs) const;

  FractionFieldElement operator-() const { return FractionFieldElement(-numerator_, denominator_); }

  FractionFieldElement operator*(const FractionFieldElement& rhs) const;

  bool operator==(const FractionFieldElement& rhs) const;

  FractionFieldElement Inverse() const;

  /*
    Converts this fraction field element to the equivalent element in the original field and
    constructs a byte serialization of this field element at the given span.
  */
  void ToBytes(gsl::span<std::byte> span_out, bool use_big_endian = true) const {
    ToBaseFieldElement().ToBytes(span_out, use_big_endian);
  }

  static constexpr FractionFieldElement Zero() {
    return FractionFieldElement(FieldElementT::Zero());
  }

  static constexpr FractionFieldElement One() { return FractionFieldElement(FieldElementT::One()); }

  /*
    Returns a fraction field element: its numerator is a random FieldElementT generated by
    FieldElementT::RandomElement of and its denominator is FieldElementT::One().
  */
  static FractionFieldElement RandomElement(PrngBase* prng) {
    return FractionFieldElement(FieldElementT::RandomElement(prng));
  }

  static FractionFieldElement FromBytes(gsl::span<const std::byte> bytes, bool use_big_endian) {
    return FractionFieldElement(FieldElementT::FromBytes(bytes, use_big_endian));
  }

  static FractionFieldElement FromString(const std::string& s) {
    return FractionFieldElement(FieldElementT::FromString(s));
  }

  std::string ToString() const { return this->ToBaseFieldElement().ToString(); }

  static constexpr auto FieldSize() { return FieldElementT::FieldSize(); }

  static constexpr FractionFieldElement Generator() {
    return FractionFieldElement(FieldElementT::Generator());
  }

  static constexpr auto PrimeFactors() { return FieldElementT::PrimeFactors(); }
  static constexpr size_t SizeInBytes() { return FieldElementT::SizeInBytes(); }

  FieldElementT ToBaseFieldElement() const { return this->numerator_ * denominator_.Inverse(); }

  /*
    Given input, a list of field elements {a/b}, converts each element to a base field element
    a*b^-1. It uses BatchInverse method for inverting the denominators efficiently. The result is
    written to output.
  */
  static void BatchToBaseFieldElement(
      gsl::span<const gsl::span<const FractionFieldElement<FieldElementT>>> input,
      gsl::span<const gsl::span<FieldElementT>> output);

  explicit operator FieldElementT() const { return ToBaseFieldElement(); }

 private:
  FieldElementT numerator_;
  FieldElementT denominator_;
};

}  // namespace starkware

#include "starkware/algebra/fields/fraction_field_element.inl"

#endif  // STARKWARE_ALGEBRA_FIELDS_FRACTION_FIELD_ELEMENT_H_
